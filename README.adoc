= Functional Utils
:toc:
:toc-placement: preamble
:functionalversion: 0.7.0
ifdef::env-github,env-gitbucket[:outfilesuffix: .adoc]
ifndef::env-asciidoclet[:srcdir: src/main/java/]
ifdef::env-asciidoclet[:srcdir:]
ifndef::env-asciidoclet[:javasuffix: .java]
ifdef::env-asciidoclet[:javasuffix: .html]

ifdef::env-github[]
image:https://travis-ci.org/ToToTec/de.tototec.utils.functional.svg?branch=master["Build Status", link="https://travis-ci.org/ToToTec/de.tototec.utils.functional"]
image:https://img.shields.io/codacy/d6a2164c269d4a0a8245c12de43c5736.svg["Codacy Badge", link="https://www.codacy.com/p/3188/dashboard"]
endif::[]

This project consists of some useful helper classes and interfaces, which help to write more functional Java code.

== Introduction

This project consists of some useful helper classes and interfaces, which help to write more functional Java code.

The classes are:

* link:{srcdir}de/tototec/utils/functional/FList{javasuffix}[`FList`] - contains static methods returning mostly `java.util.List` s and accepting `Iterable` s and arrays, like `map`, `flatMap`, `filter`, ...
* link:{srcdir}de/tototec/utils/functional/F0{javasuffix}[`F0`], link:{srcdir}de/tototec/utils/functional/F1{javasuffix}[`F1`], link:{srcdir}de/tototec/utils/functional/F2{javasuffix}[`F2`], ... - Interfaces representing a function with n args where n is already in the name
* link:{srcdir}de/tototec/utils/functional/Procedure0{javasuffix}[`Procedure0`], link:{srcdir}de/tototec/utils/functional/Procedure1{javasuffix}[`Procedure1`], link:{srcdir}de/tototec/utils/functional/Procedure2{javasuffix}[`Procedure2`] - Interfaces representing a procedure with n args where n is given by the name
* link:{srcdir}de/tototec/utils/functional/Optional{javasuffix}[`Optional`] - An immutable class representing an optional value
* link:{srcdir}de/tototec/utils/functional/Either{javasuffix}[`Either`] - An immutable class representing either one of two values
* link:{srcdir}de/tototec/utils/functional/Tuple2{javasuffix}[`Tuple2`], link:{srcdir}de/tototec/utils/functional/Tuple3{javasuffix}[`Tuple3`], ... - Classes representing tuples with n args where n is given by the name

All those classes and interfaces can be used with Java 5 and above. Although by their use, your code will not get more compact, but hopefully less errorprone.

== Examples

[source,java]
----
import java.util.*;
import de.tototec.utils.functional.*;
import static de.tototec.utils.functional.FList.*;

List<String> names = Arrays.asList("Alice", "Bob", "Carlie", "Dylan");
// --> [Alice, Bob, Carlie, Dylan]

// Filtering
List<String> namesWithE = filter(names, new F1<String, Boolean>() {
  public Boolean apply(String name) {
    return name.contains("e");
  }
});
// --> [Alice, Carlie]

// Java 8
List<String> namesWithE_ = filter(names, name -> name.contains("e"));

// Apply a function to all elements
List<String> namesUppercase = map(names, new F1<String, String>() {
  public String apply(String name) {
    return name.toUppercase();
  }
});
// --> [ALICE, BOB, CARLIE, DYLAN]

// Java 8
List<String> namesUppercase_ = map(names, name -> name.toUppercase());
// --> [ALICE, BOB, CARLIE, DYLAN]


----

// TODO: Examples

(Example will come later)

== Download

Functional Utils is available from http://search.maven.org/#search|gav|1|g%3A%22de.tototec%22%20AND%20a%3A%22de.tototec.utils.functional%22[Maven central repository].

Maven users can use the following dependency declaration:

[source,xml,subs="attributes,verbatim"]
----
<dependency>
  <groupId>de.tototec</groupId>
  <artifactId>de.tototec.utils.functional</artifactId>
  <version>{functionalversion}</version>
</dependency>
----

http://sbuild.org[SBuild] users can use the following dependency:

[source,scala,subs="attributes"]
----
"mvn:de.tototec:de.tototec.utils.functional:{functionalversion}"
----


== Use with Java 8 Lambdas

Writing functional code can be much more pleasant if Java 8 Lambda expressions can be used. The function and procedure interfaces all fulfil the requirements for functional interfaces and can be thus implicitly inferred when lambda expressions are used.

== Use of Java 8 Lambdas for earlier Java Runtimes

Using the Java 8 lamdba expressions can grealty improve the functional experience.
If you need to target an older Java Runtime, down to Java 5, you can still compile your code with a Java 8 compiler and afterwards postprocess the classfiles with the https://github.com/orfjackal/retrolambda[retrolambda tool].
As long as you only use the Lambda syntax but no other new API from Java 8, your code will also run in Java 7 and before.

To use Retrolambda in your Maven project, you need to add something like this (please refer also to the Retrolambda website for more up to date information):

[source,xml]
----
<plugin>
    <groupId>net.orfjackal.retrolambda</groupId>
    <artifactId>retrolambda-maven-plugin</artifactId>
    <version>1.6.1</version>
    <executions>
        <execution>
            <goals>
                <goal>process-main</goal>
                <goal>process-test</goal>
            </goals>
        </execution>
    </executions>
</plugin>
----

Addionally, you should take extra measure to ensure no Java8 API slips through.
This can be achieved with the http://mojo.codehaus.org/animal-sniffer-maven-plugin/[animal-sniffer Maven plugin]:

[source,xml]
----
<plugin>
	<groupId>org.codehaus.mojo</groupId>
	<artifactId>animal-sniffer-maven-plugin</artifactId>
	<version>1.11</version>
	<executions>
		<execution>
			<id>signature-check</id>
			<phase>test</phase>
			<goals>
				<goal>check</goal>
			</goals>
		</execution>
	</executions>
	<configuration>
		<signature>
			<groupId>org.codehaus.mojo.signature</groupId>
			<artifactId>java17</artifactId>
			<version>1.0</version>
		</signature>
	</configuration>
</plugin>
----

== Changelog

=== 0.7.0 - 2016-06-01

* Fixed faulty FList.distict method
* Added no-op impls for Procedure interfaces
* Improved / fixed signature of FList.flatten
* Changed toString of Optional
* Added FList.headOption
* Added FList.tail
* Added Optional.getOrElseF
* Added Optional.orElse and Optional.orElseF
* Added FList.filterNotNull
* Added FList.concat

=== 0.6.0 - 2015-11-11

* Changed order of type parameters in methods of FList
* Added Optional.getOrElse
* Added Optional.foreach
* Added FList.contains
* Added FList.containsAll
* Added FList.toHashMap

=== 0.5.0 - 2014-11-14

* Initial Release after migration to GitHub
